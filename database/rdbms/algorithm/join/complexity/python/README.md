# RDBMS Join Algorithm Complexity Simulator (Python版)

RDBMSのテーブル結合アルゴリズム（Nested Loop Join, Hash Join）をシミュレートし、性能を測定するPython製CLIツールです。

## 概要

このシミュレーターは、以下の結合アルゴリズムの実装と性能測定を提供します:

- **Nested Loop Join (NLJ)**: 内部表の各レコードに対して外部表を逐次スキャン
- **Hash Join (HJ)**: 内部表でハッシュテーブルを構築し、外部表をスキャンして結合

インデックスの使用有無による性能差を体験でき、計算量(Big-O)の解析結果も表示されます。

## 特徴

- Python標準ライブラリのみを使用（外部依存なし）
- 型アノテーション完備（mypy準拠）
- 実際の処理時間を測定
- 詳細なログ出力（アクセス回数、計算量解析）
- Bツリーインデックスをbisectモジュールでシミュレート

## 必要環境

- Python 3.8以上

## 使用方法

### 基本実行

```bash
python main.py -a <内部表万件> -b <フェッチ比率%> -j <アルゴリズム> -c <外部表万件> -d <結合係数>
```

### パラメータ

| オプション | 説明 | 必須 | 例 |
|-----------|------|------|-----|
| `-a, --inner-total` | 内部表母数（万件） | ✓ | `10` |
| `-b, --fetch-ratio` | 内部表フェッチ比率（1-100%） | ✓ | `50` |
| `--inner-use-index` | 内部表でインデックスを使用 | - | - |
| `-j, --join-algorithm` | 結合アルゴリズム（`nlj` or `hj`） | ✓ | `nlj` |
| `-c, --outer-total` | 外部表母数（万件） | ✓ | `100` |
| `-d, --join-factor` | 外部表一致比率（0.01以上） | ✓ | `5` |
| `--outer-use-index` | 外部表でインデックスを使用（NLJのみ） | - | - |
| `--filter-value` | WHERE条件値（デフォルト: 20） | - | `20` |

### 実行例

#### 例1: Nested Loop Join（両方インデックス使用）

```bash
python main.py -a 10 -b 50 --inner-use-index -j nlj -c 100 -d 5 --outer-use-index
```

**期待される結果:**
- 内部表: O(log n) でフェッチ
- 外部表: O(log c) で検索
- 総計算量: O(m × log c)
- 実行時間: 非常に高速

#### 例2: Nested Loop Join（インデックス未使用）

```bash
python main.py -a 10 -b 50 -j nlj -c 100 -d 5
```

**期待される結果:**
- 内部表: O(n) でフルスキャン
- 外部表: O(c) でフルスキャン
- 総計算量: O(m × c)
- 実行時間: 例1より大幅に遅い

#### 例3: Hash Join（内部表インデックス使用）

```bash
python main.py -a 5 -b 100 --inner-use-index -j hj -c 50 -d 2
```

**期待される結果:**
- 内部表: O(log n) でフェッチ
- Build Phase: O(m) でハッシュテーブル構築
- Probe Phase: O(c) で外部表スキャン
- 総計算量: O(m + c)
- 実行時間: NLJ（インデックス未使用）より高速

## 出力例

```
============================================================
RDBMS Join Algorithm Simulator
============================================================
内部表: 100,000 レコード
フェッチ比率: 50.0%
内部表インデックス: 使用
結合アルゴリズム: nlj
外部表: 1,000,000 レコード
結合係数: 5.0
外部表インデックス: 使用
WHERE条件値: 20

テストデータを生成中...
  内部表: 100,000 レコード生成
  外部表: 1,000,000 レコード生成
データ生成完了

結合を実行中...

============================================================
実行結果
============================================================
アルゴリズム: Nested Loop Join
実行時間: 45.123 ms
内部表アクセス回数: 1
外部表アクセス回数: 50,000
結合結果件数: 250,000

============================================================
計算量解析
============================================================
Nested Loop Join (両方インデックス使用)
  内部表スキャン: O(log n + m) = O(log 100000 + 50000) ≈ 1
  外部表スキャン: O(m × (log c + d)) = O(50000 × (log 1000000 + 5)) ≈ 50000
  総計算量: O(m × log c) where m=50000, c=1000000
```

## アルゴリズム詳細

### Nested Loop Join

**アルゴリズムフロー:**
1. 内部表フェッチ（WHERE条件）
2. fetch_ratio適用
3. 各内部表レコードに対して外部表をスキャン

**計算量:**
| 内部表 | 外部表 | 計算量 |
|--------|--------|--------|
| インデックス | インデックス | O(log n + m × log c) |
| インデックス | フルスキャン | O(log n + m × c) |
| フルスキャン | インデックス | O(n + m × log c) |
| フルスキャン | フルスキャン | O(n + m × c) |

### Hash Join

**アルゴリズムフロー:**
1. 内部表フェッチ（WHERE条件）
2. Build Phase: ハッシュテーブル構築
3. Probe Phase: 外部表スキャン+ハッシュ検索

**計算量:**
| 内部表 | 計算量 |
|--------|--------|
| インデックス | O(log n + m + c) |
| フルスキャン | O(n + m + c) |

**注:** Hash Joinでは外部表インデックスは使用されません

## 想定SQL

シミュレーターは以下のようなSQLを想定しています:

```sql
SELECT b.column_value
FROM inner_table a
INNER JOIN outer_table b ON a.column_value = b.filter_key
WHERE a.filter_key = 20
```

## アーキテクチャ

```
join_simulator/
├── data/                    # データ構造
│   ├── table.py             # TableRecord, TableData, IndexData
│   └── generator.py         # テストデータ生成
├── join/                    # 結合アルゴリズム
│   ├── base.py              # 抽象基底クラス
│   ├── nested_loop.py       # NLJ実装
│   └── hash_join.py         # HJ実装
├── metrics/                 # 計測・分析
│   └── complexity.py        # Big-O計算量算出
└── cli.py                   # CLI引数パーサー
```

## 参照実装

このPython版は、以下のRust版実装を参考にしています:
- [../rust/](../rust/) - Rust版実装

## ライセンス

このプロジェクトは教育目的で作成されています。

## 貢献

バグ報告や機能追加の提案は Issue でお願いします。
